#! /usr/bin/env python
import sys
from pprint import pprint
import subprocess
import platform
import tarfile
import StringIO
from optparse import OptionParser
import os
import hashlib
import difflib

if sys.version_info >= (3,):
	import urllib.request as urllib2
	import urllib.parse as urlparse
else:
	import urllib2
	import urlparse

if sys.version_info > (2,6,):
	import json
else:
	import simplejson as json #json module is introduce in python 2.4.3

def md5_cal(filename, block_size=2**20):
	try:
		with open(filename, 'rb') as f:
			md5 = hashlib.md5()
			while True:
				data = f.read(block_size)
				if not data:
					break
				md5.update(data)
			return md5.hexdigest()
	except:
		sys.exit("md5_cal(" + filename + ") failed.\n")

def url_check(url):
	try:
		f = urllib2.urlopen(urllib2.Request(url))
	except:
		print "url({0}) is broken.".format(url)
		return 1
	return 0

def download_func(url, checksum, checksum_tool, dest, format_remote_storage, package_dir, branch_name):
	dir_dest = os.path.dirname(dest)
	try:
		response = urllib2.urlopen(url)
		data = response.read()
	except URLerror as e:
		print "URLerror({0}): {1}".format(e.errno, e.strerror)
		sys.exit(0)
	scheme, netloc, path, query, fragment = urlparse.urlsplit(url)
	filename = os.path.basename(path)

	if format_remote_storage == "plain-text":
		dest = os.path.join(package_dir, dest)
		#with open(dest, "wb") as code: with open is not available in python 2.4.3
		with open(dest, "wb") as code:
			code.write(data)
		if checksum_tool == "md5sum":
			local_checksum = md5_cal(dest)
		else:
			sys.exit(checksum_tool + "is not supported currently!")
		if not local_checksum == checksum:
			print local_checksum, checksum
			sys.exit("the version of " + url + " is incorrect!\n")
	elif format_remote_storage == "tar":
		dest_dir = os.path.join(package_dir, dir_dest)
		dest = os.path.join(dest_dir, filename)
		if not os.path.exists(dest_dir):
			os.makedirs(dest_dir)
		with open(dest, "wb") as code:
			code.write(data)
		if checksum_tool == "md5sum":
			local_checksum = md5_cal(dest)
		else:
			sys.exit(checksum_tool + "is not supported currently!")
		if not local_checksum == checksum:
			print local_checksum, checksum
			sys.exit("the version of " + url + " is incorrect!\n")
		tfile = tarfile.open(dest, "r:")
		tfile.extractall(dest_dir)
		os.remove(dest)
		'''
		no checksum verification process
		dest = os.path.join(package_dir, dir_dest)
		compressedFile = StringIO.StringIO()
		compressedFile.write(data)
		compressedFile.seek(0)
		tfile = tarfile.open(mode="r:", fileobj = compressedFile);
		tfile.extractall(dest)
		'''
	elif format_remote_storage == "tgz":
		dest_dir = os.path.join(package_dir, dir_dest)
		dest = os.path.join(dest_dir, filename)
		if not os.path.exists(dest_dir):
			os.makedirs(dest_dir)
		with open(dest, "wb") as code:
			code.write(data)
		if checksum_tool == "md5sum":
			local_checksum = md5_cal(dest)
		else:
			sys.exit(checksum_tool + "is not supported currently!")
		if not local_checksum == checksum:
			print local_checksum, checksum
			sys.exit("the version of " + url + " is incorrect!\n")
		tfile = tarfile.open(dest, "r:gz")
		tfile.extractall(dest_dir)
		os.remove(dest)
		'''
		tfile = tarfile.open(mode="r:gz", fileobj = compressedFile);
		tfile.extractall(dest)
		'''
	elif format_remote_storage == "git":
		dest_dir = os.path.join(package_dir, dir_dest)
		if not os.path.exists(dest_dir):
			os.makedirs(dest_dir)
		os.chdir(dest_dir)
		subprocess.call("git clone -b " + branch_name + " " + url, shell = True)
		filename = filename[:-4]
		dest_path = os.path.join(package_dir, dest)
		if not os.path.exists(dest_path):
			subprocess.call("mv " + filename + " " + dest_path, shell = True)
		os.chdir(dest_path)
		subprocess.call("git checkout " + checksum, shell = True)
	else:
		sys.exit("this format is not supported currently!\n")

#Problem: this function needs extension: redirection of remote dependencies
def remote_dependencies_check(remote_dependencies, package_dir, behavior):
	print "remote dependencies checking ..."
	for item_1 in remote_dependencies:
		item = remote_dependencies[item_1]
		pprint(item)
		url = item["remote-storage-location"]
		if url_check(url) == 1:
			sys.exit(0)
		checksum = item["checksum"]
		checksum_tool = item["checksum-tool"]
		dest = item["location-in-package"]
		format_remote_storage = item["remote-storage-format"]
		if format_remote_storage == "git":
			branch_name = item["branch-name"]
		else:
			branch_name = ""
		download_func(url, checksum, checksum_tool, dest, format_remote_storage, package_dir, branch_name)

#Problem: this function needs extension: check whether the VM satisfies the requirement; how to set the imperfect match range.
def execution_environment_check(execution_environment):
	print "execution environment checking ..."
	uname_list = platform.uname() #(system,node,release,version,machine,processor)
	for i in range(len(uname_list)):
		print uname_list[i],
	print ''
	#linux_dist = platform.linux_distribution() #(distname,version,id)
	linux_dist = platform.dist() #(distname,version,id) #platform.linux_distribution is not available in python 2.4.3
	for i in range(len(linux_dist)):
		print linux_dist[i],
	print ''

def package_combination(package_structure, package_dir, behavior):
	print "combining package ..."
	#pprint(package_structure)
	if not os.path.exists(package_dir):
		os.makedirs(package_dir)
	for item_1 in package_structure:
		item = package_structure[item_1]
		url = item["remote-storage-location"]
		format_package = item["format-in-package"]
		dest = item["location-in-package"]
		format_remote_storage = item["remote-storage-format"]
		checksum_tool = item["checksum-tool"]
		checksum = item["checksum"]
		download_func(url, checksum, checksum_tool, dest, format_remote_storage, package_dir, "")

def software_combination(software_dependencies, package_dir, behavior):
	print "combine software dependencies ..."
	#pprint(software_dependencies)
	for item1 in software_dependencies:
		item = software_dependencies[item1]
		name = item["name"]
		is_networked_resources = item["is-networked-resources"]
		if is_networked_resources == "yes":
			pprint(item)
			sys.exit(name + " should be installed and configured.\n")

def workflow_repeat(workflow, package_dir, method, behavior):
	print "workflow repeating ..."
	#pprint(workflow)
	os.chdir(package_dir)
	env_list = package_dir + '/' + workflow["environment-variable-list"]["location-in-package"]
	if behavior == "run":
		analysis_command = workflow["analysis-program"]["analysis-tool"] + ' ' + workflow["analysis-program"]["analysis-script"] + '\n'
		with open('repeat_workflow', 'w') as file:
			file.write(analysis_command)

		print "**************************************************************************\n"
		print "The analysis program are collected in the file: /repeat_workflow.\n"
		print "You can also directly run the following command to repeat the experiment:\n"
		print analysis_command
		print "after everything is done, run the command `exit` to exit.\n"
		print "**************************************************************************\n"

	if method == "parrot":
		if behavior == "run":
			try:
				subprocess.call("parrot_package_run -p " + package_dir + " -e " + env_list, shell = True)
			except:
				sys.exit("Repeat workflow failed.\n")
		elif behavior == "setup" or behavior == "localize":
			print "All the necessary preparations have finished! The repeat shell is: " + package_dir + "/repeat-workflow\n"
		else:
			pass
	else:
		if behavior == "run":
			try:
				subprocess.call("chroot_package_run -p " + package_dir + " -e " + env_list, shell = True)
			except:
				sys.exit("Repeat workflow failed.\n")
		elif behavior == "setup" or behavior == "localize":
			print "All the necessary preparations have finished! The repeat shell is: " + package_dir + "/repeat-workflow\n"
		else:
			pass

def compare_json(json_1, json_2, name_1, name_2):
	for item in json_1:
		if item not in json_2:
			print "Item %s in \"%s\", but not in \"%s\"" %(item, name_1, name_2)
			print "<<<<<<<<%s in %s:" %(item, name_1)
			pprint(json_1[item])
			print "\n"
		elif json_1[item] != json_2[item]:
			print "Item %s in both files, but values differ:" %item
			print "<<<<<<<<%s in %s:" %(item, name_1)
			pprint(json_1[item])
			print ">>>>>>>>%s in %s:" %(item, name_2)
			pprint(json_2[item])
			print "\n"
	for item in json_2:
		if item not in json_1:
			print "Item %s in \"%s\", but not in \"%s\"" %(item, name_2, name_1)
			print ">>>>>>>>%s in %s:" %(item, name_2)
			pprint(json_2[item])
			print "\n"

def specification_process(json_package, package_dir, method, behavior):

	if json_package.has_key("physics-software") and json_package["physics-software"]:
		software_combination(json_package["physics-software"], package_dir, behavior)
	else:
		print "this spec has no physics-software"

	if json_package.has_key("remote-dependencies") and json_package["remote-dependencies"]:
		has_broken_link = remote_dependencies_check(json_package["remote-dependencies"], package_dir, behavior)
		if has_broken_link == 1:
			sys.exit(0)
	else:
		print "this spec has no remote dependencies part"

	if json_package.has_key("execution-environment") and json_package["execution-environment"]:
		execution_environment_check(json_package["execution-environment"])
	else:
		print "this spec has no execution-environment"

	if json_package.has_key("filesystem-structure") and json_package["filesystem-structure"]:
		package_combination(json_package["filesystem-structure"], package_dir, behavior)
	else:
		print "this spec has no filesystem-structure"

	#software combination

	if json_package.has_key("workflow") and json_package["workflow"]:
		workflow_repeat(json_package["workflow"], package_dir, method, behavior)
	else:
		print "this spec has no workflow"

def dependency_check():
	dependency_list = ["git", "mv", "parrot_package_run", "chroot_package_run"]
	for item in dependency_list:
		print "dependency check -- ", item, '\n'
		p = subprocess.Popen("which " + item, stdout = subprocess.PIPE, shell = True)
		(output, err) = p.communicate()
		p_status = p.wait()
		if p_status != 0:
			sys.exit("command `which(" + item + ")` failed. Please install " + item + " and ensure its directory be added into the PATH environment varibale.\n")
	
def main():
	#Problem: extension support incremental download
	parser = OptionParser(usage="usage: %prog [options] run/setup/localize/merge/diff [spec_1] [spec_2]",
						version="%prog 1.0")
	parser.add_option("-c", "--config",
					action="store",
					default="./package.json",
					help="The specification json file")
	parser.add_option("-s", "--sandbox",
					action="store", # optional because action defaults to "store"
					default="./test",
					help="The path of sandbox",)
	parser.add_option("-m", "--method",
					action="store", # optional because action defaults to "store"
					default="parrot",
					help="Repeat method (chroot:require root account; parrot: does not require root account.)",)
	parser.add_option("--source",
					action="store", # optional because action defaults to "store"
					help="The specification source.",)
	parser.add_option("--target",
					action="store", # optional because action defaults to "store"
					help="The specification destination.",)
	(options, args) = parser.parse_args()

	behavior = args[0]
	if behavior not in ["run", "setup", "localize", "merge", "diff"]:
		print "Behaviors currently supported by spectool: run, setup, localize, merge, and diff.\n"
		sys.exit(0)

	if behavior in ["run", "setup", "localize", "merge"]:
		if len(args) != 1:
			parser.error("wrong number of arguments!")
			sys.exit(0)
		package_dir = options.sandbox
		package_dir = os.path.abspath(package_dir)
		if os.path.exists(package_dir):
			print "This sandbox already exists! Please choose another sandbox or first delete this sandbox!!\n"
			sys.exit(0)
		method = options.method
		if method == "chroot" and os.getuid() != 0:
			print "chroot method needs root authority! Please first log in as the root account and then run the program again!!\n"
			sys.exit(0)
		if method != "chroot" and method != "parrot":
			print "spectool currently only support two methods: parrot and chroot.\n"
			sys.exit(0)
		json_file = options.config
		if not os.path.isfile(json_file):
			print "The json file does not exists! Please check!!\n"
			sys.exit(0)
		with open(json_file) as json_data: #python 2.4 does not support this syntax: with open () as
			json_spec = json.load(json_data)
			package_spec = json_spec["package"]

	if behavior in ["run", "setup", "localize"]:
		dependency_check()
		specification_process(package_spec, package_dir, method, behavior)

	if behavior == "localize":
		package_spec["package-location"] = package_dir
		new_json = "local.json"
		outfile_name = os.path.join(package_dir, new_json)
		with open(outfile_name, "w") as outfile:
			json.dump(json_spec, outfile, indent = 4)
		print "The localized version of the specification is: " + new_json + '\n'

	if behavior == "diff":
		if len(args) != 3:
			parser.error("wrong number of arguments! The diff behavior needs two specification files.")
		with open(args[1]) as json1_data:
			json1 = json.load(json1_data)
		with open(args[2]) as json2_data:
			json2 = json.load(json2_data)
		compare_json(json1["package"]["remote-dependencies"], json2["package"]["remote-dependencies"], args[1], args[2])
		compare_json(json1["package"]["execution-environment"], json2["package"]["execution-environment"], args[1], args[2])
		compare_json(json1["package"]["filesystem-structure"], json2["package"]["filesystem-structure"], args[1], args[2])
		compare_json(json1["package"]["physics-software"], json2["package"]["physics-software"], args[1], args[2])
		compare_json(json1["package"]["workflow"], json2["package"]["workflow"], args[1], args[2])

	if behavior == "merge":
		if package_spec.has_key("basic-specification") and os.path.exists(package_spec["basic-specification"]):
			basic_json_filename = package_spec["basic-specification"]
			print "The specification has a basic specification:" + basic_json_filename
			with open(basic_json_filename) as basic_json:
				basic_spec = json.load(basic_json)
			basic_package = basic_spec["package"]
		else:
			print "The basic specification does not exist"
			sys.exit(0)
		if basic_package.has_key("package-location") and os.path.isdir(basic_package["package-location"]):
			print "the target is a localized version"
		else:
			print "the target does not exist"
			specification_process(basic_package, package_dir, method, behavior)
		specification_process(package_spec, package_dir, method, behavior)

if __name__ == "__main__":
	main()

#set sts=4 sw=4 ts=4 expandtab ft=python
