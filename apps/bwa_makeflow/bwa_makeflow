#! /usr/bin/env python
#
#Copyright (C) 2013- The University of Notre Dame
#This software is distributed under the GNU General Public License.
#See the file COPYING for details.
#
# This program implements a distributed version of BWA, using Makeflow and WorkQueue

# Author: Nick Hazekamp
# Date: 09/03/2013


import optparse, os, sys, re, string, logging as log


def stop_err( msg ):
	sys.stderr.write( "%s\n" % msg )
	sys.exit()

def search_file(filename, search_path, pathsep=os.pathsep):
    """ Given a search path, find file with requested name """
    for path in string.split(search_path, pathsep):
        candidate = os.path.join(path, filename)
        if os.path.exists(candidate): return os.path.abspath(candidate)
    return None


def count_splits( fastq ):
	num_reads=50000
	num_outputs = 0
	line_count=0

	FILE = open(fastq, "r")

	read_count = 0
	num_outputs += 1
	for line in FILE:
		if (re.search('^[@]', line) and line_count % 4 ==0):
			if (read_count == num_reads):
				num_outputs += 1
				read_count = 0	
			else:
				read_count += 1
		#place all other lines in FASTQ file under same sequence
		line_count += 1
	FILE.close()
	return num_outputs

index_arg = ""
def index_args(option, opt_str, value, parser):
	global index_arg
	index_arg += opt_str[-2:] + " " + value + " "

def parse_index(parser):
	group = optparse.OptionGroup(parser, "Index Arguments")
	group.add_option('--index-a',type="string",help="BWT construction algoritm: bwtsw or is [auto]",action="callback",callback=index_args)
	group.add_option('--index-p',type="string",help="Prefix of the index [same as fasta name]",dest="prefix")
	parser.add_option_group(group)

bwamem_arg = ""
def mem_args(option, opt_str, value, parser):
	global bwamem_arg
	bwamem_arg += opt_str[-2:] + " " + value + " "

def parse_mem(parser):
	group = optparse.OptionGroup(parser, "MEM Arguments")
	group.add_option('--mem-t',type="string",help="Number of threads [1]",action="callback",callback=mem_args)
	group.add_option('--mem-k',type="string",help="Minimum seed length [19]",action="callback",callback=mem_args)
	group.add_option('--mem-w',type="string",help="Band width for banded alignment [100]",action="callback",callback=mem_args)
	group.add_option('--mem-d',type="string",help="Off-diagonal X-dropoff [100]",action="callback",callback=mem_args)
	group.add_option('--mem-r',type="string",help="Look for internal seeds inside a seed longer than {-k}*FLOAT [1.5]",action="callback",callback=mem_args)
	group.add_option('--mem-c',type="string",help="Skip seeds with more than INT occurrences [10000]",action="callback",callback=mem_args)
	group.add_option('--mem-S',default="",help="Skip mate rescue",action="callback",callback=mem_args)
	group.add_option('--mem-P',default="",help="Skip pairing; mate rescue performed unless -S also in use",action="callback",callback=mem_args)
	group.add_option('--mem-A',type="string",help="Score for a sequence match [1]",action="callback",callback=mem_args)
	group.add_option('--mem-B',type="string",help="Penalty for a mismatch [4]",action="callback",callback=mem_args)
	group.add_option('--mem-O',type="string",help="Gap open penalty [6]",action="callback",callback=mem_args)
	group.add_option('--mem-E',type="string",help="Gap extension penalty; a gap of size k cost {-O}+{-E}*k [1]",action="callback",callback=mem_args)
	group.add_option('--mem-L',type="string",help="Penalty for clipping [5]",action="callback",callback=mem_args)
	group.add_option('--mem-U',type="string",help="Penalty for an unpaired read pair [17]",action="callback",callback=mem_args)
	group.add_option('--mem-p',default="",help="First query file consists of interleaved paired-end sequences",action="callback",callback=mem_args)
	group.add_option('--mem-R',type="string",help="Read group header line such as '@RG\\tID:foo\\tSM:bar'. [null]",action="callback",callback=mem_args)
	#group.add_option('--mem-v',type="string",help="Verbose level: 1=error, 2=warning, 3=message, 4+=debugging [3]",action="callback",callback=mem_args)
	group.add_option('--mem-T',type="string",help="Minimum score to output [30]",action="callback",callback=mem_args)
	group.add_option('--mem-a',default="",help="Output all alignments for SE or unpaired PE",action="callback",callback=mem_args)
	group.add_option('--mem-C',default="",help="Append FASTA/Q comment to SAM output",action="callback",callback=mem_args)
	group.add_option('--mem-H',default="",help="Use hard clipping 'H' in SAM output",action="callback",callback=mem_args)
	group.add_option('--mem-M',default="",help="Mark shorter split hits as secondary (for Picard/GATK compatibility)",action="callback",callback=mem_args)
	parser.add_option_group(group)


aln_arg = ""
def aln_args(option, opt_str, value, parser):
	global aln_arg
	aln_arg += opt_str[-2:] + " " + value + " "

def parse_aln(parser):
	group = optparse.OptionGroup(parser, "ALN Arguments")
	group.add_option('--aln-n',type="string",help="Max #diff INT or missing prob under 0.02 err rate (float) [0.04]",action="callback",callback=aln_args)
	group.add_option('--aln-o',type="string",help="Maximum number or fraction of gap opens [1]",action="callback",callback=aln_args)
	group.add_option('--aln-e',type="string",help="Maximum number of gap extensions, -1 for disabling long gaps [-1]",action="callback",callback=aln_args)
	group.add_option('--aln-i',type="string",help="Do not put an indel within INT bp towards the end",action="callback",callback=aln_args)
	group.add_option('--aln-d',type="string",help="Maximum occurrence for extending a long deletion [10]",action="callback",callback=aln_args)
	group.add_option('--aln-l',type="string",help="Seed length [32]",action="callback",callback=aln_args)
	group.add_option('--aln-k',type="string",help="Maximum differences in the seed [2]",action="callback",callback=aln_args)
	group.add_option('--aln-m',type="string",help="Maximum entries in the queue [2000000]",action="callback",callback=aln_args)
	group.add_option('--aln-t',type="string",help="Number of threads [1]",action="callback",callback=aln_args)
	group.add_option('--aln-M',type="string",help="Mismatch penalty [3]",action="callback",callback=aln_args)
	group.add_option('--aln-O',type="string",help="Gap open penalty [11]",action="callback",callback=aln_args)
	group.add_option('--aln-E',type="string",help="Gap extension penalty [4]",action="callback",callback=aln_args)
	group.add_option('--aln-R',type="string",help="Stop searching when there are >INT equally best hits [30]",action="callback",callback=aln_args)
	group.add_option('--aln-q',type="string",help="Quality threshold for read trimming down to 35bp [0]",action="callback",callback=aln_args)
	group.add_option('--aln-f',type="string",help="File to write output to instead of stdout",action="callback",callback=aln_args)
	group.add_option('--aln-B',type="string",help="Length of barcode",action="callback",callback=aln_args)
	group.add_option('--aln-L',default="",help="Log-scaled gap penalty for long deletions",action="callback",callback=aln_args)
	group.add_option('--aln-N',default="",help="Non-iterative mode: search for all n-difference hits (slow_",action="callback",callback=aln_args)
	group.add_option('--aln-I',default="",help="The input is in the Illumina 1.3+ FASTQ-like format",action="callback",callback=aln_args)
	group.add_option('--aln-b',default="",help="The input read file is in BAM format",action="callback",callback=aln_args)
	group.add_option('--aln-0',default="",help="Use single-end reads only (effective with -b)",action="callback",callback=aln_args)
	group.add_option('--aln-1',default="",help="Use the 1st read in a pair (effective with -b)",action="callback",callback=aln_args)
	group.add_option('--aln-2',default="",help="Use the 2nd read in a pair (effective with -b)",action="callback",callback=aln_args)
	group.add_option('--aln-Y',default="",help="Filter Casava-filtered sequences",action="callback",callback=aln_args)
	parser.add_option_group(group)


samse_arg = ""
def samse_args(option, opt_str, value, parser):
	global samse_arg
	samse_arg += opt_str[-2:] + " " + value + " "

def parse_samse(parser):
	group = optparse.OptionGroup(parser, "SAMSE Arguments")
	group.add_option('--samse-n',type="string",help="Maximum hits to output for paired reads [3]",action="callback",callback=samse_args)
	group.add_option('--samse-f',type="string",help="Sam file to output results to",action="callback",callback=samse_args)
	group.add_option('--samse-r',type="string",help="Read group header line such as '@RG\\tID:foo\\tSM:bar' [null]",action="callback",callback=samse_args)
	parser.add_option_group(group)


sampe_arg = ""
def sampe_args(option, opt_str, value, parser):
	global sampe_arg
	sampe_arg += opt_str[-2:] + " " + value + " "

def parse_sampe(parser):
	group = optparse.OptionGroup(parser, "SAMPE Arguments")
	group.add_option('--sampe-a',type="string",help="Maximum insert size [500]",action="callback",callback=sampe_args)
	group.add_option('--sampe-o',type="string",help="Maximum occurrences for one end [100000]",action="callback",callback=sampe_args)
	group.add_option('--sampe-n',type="string",help="Maximum hits to output for paired reads [3]",action="callback",callback=sampe_args)
	group.add_option('--sampe-N',type="string",help="Maximum hits to output for discordant pairs [10]",action="callback",callback=sampe_args)
	group.add_option('--sampe-c',type="string",help="Prior of chimeric rate (lower bound) [1.0e-05]",action="callback",callback=sampe_args)
	group.add_option('--sampe-f',type="string",help="Sam file to output results to",action="callback",callback=sampe_args)
	group.add_option('--sampe-r',type="string",help="Read group header line such as '@RG\\tID:foo\\tSM:bar' [null]",action="callback",callback=sampe_args)
	group.add_option('--sampe-P',default="",help="Preload index into memory (for base-space reads only)",action="callback",callback=sampe_args)
	group.add_option('--sampe-s',default="",help="Disable Smith-Waterman for the unmapped mate",action="callback",callback=sampe_args)
	group.add_option('--sampe-A',default="",help="Disable insert size estimate (force -s)",action="callback",callback=sampe_args)
	parser.add_option_group(group)


bwasw_arg = ""
def bwasw_args(option, opt_str, value, parser):
	global bwasw_arg
	bwasw_arg += opt_str[-2:] + " " + value + " "

def parse_bwasw(parser):
	group = optparse.OptionGroup(parser, "BWASW Arguments")
	group.add_option('--bwasw-a',type="string",help="Score for a match [1]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-b',type="string",help="Mismatch penalty [3]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-q',type="string",help="Gap open penalty [5]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-r',type="string",help="Gap extension penalty [2]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-w',type="string",help="Band width[50]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-m',type="string",help="Mask level [0.50]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-t',type="string",help="Number of threads [1]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-f',type="string",help="File to output results to instead of stdout",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-H',default="",help="In SAM output, use hard clipping instead of soft clipping",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-C',default="",help="Copy FASTA/Q comment to SAM output",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-M',default="",help="Mark multi-part alignments as secondary",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-S',default="",help="Skip Smith-Waterman read pairing",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-I',type="string",help="Ignore pairs with insert >=INT for inferring the size distr [20000]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-T',type="string",help="Score threshould divided by a [30]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-c',type="string",help="Coefficient of length-threshold adjustmnet [5.5]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-z',type="string",help="Z-best [1]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-s',type="string",help="Maximum seeding interval size [3]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-N',type="string",help="# seeds to trigger rev aln; 2*INT is also the chaining threshold [5]",action="callback",callback=bwasw_args)
	group.add_option('--bwasw-G',type="string",help="Maximum gap size during chaining [10000]",action="callback",callback=bwasw_args)
	parser.add_option_group(group)


#MAIN

    #Parse Command Line
parser = optparse.OptionParser(usage="usage: %prog --ref ref.fa --fastq query.fq [options]")
parser.add_option('--ref', dest='ref', help='The reference genome to use or index')
parser.add_option('--fastq', dest='fastq', help='The (forward) fastq file to use for the mapping')
parser.add_option('--rfastq', dest='rfastq', help='The reverse fastq file to use for mapping if paired-end data')
parser.add_option('--output_SAM', dest='output_SAM', help='The file to save the output (SAM format) [bwa_results.sam]')
parser.add_option('--algoalign', dest='algoalign', help='The type of Alignment Algorithm (backtrack, bwasw, mem) [mem]')
parser.add_option('--makeflow', dest='makeflow', help='Makeflow destination file [stdout]')
parser.add_option('--makeflow-config', dest='config', help='Makeflow configurations')
parser.add_option('--verbose', dest='verbose', help='Show verbose level output', action='store_true',default="False")

parse_index(parser)
parse_mem(parser)
parse_aln(parser)
parse_samse(parser)
parse_sampe(parser)
parse_bwasw(parser)

(options, args) = parser.parse_args()

if options.verbose == True:
        log.basicConfig(format="%(levelname)s: %(message)s", level=log.DEBUG)
        log.info("Verbose output.")
else:
        log.basicConfig(format="%(levelname)s: %(message)s")

if not options.ref:
	log.error("No reference file: --ref required")

if not options.fastq:
	log.error("No query file: --fastq required")

path = os.getenv("PATH")
path += os.pathsep + os.pathsep + "."

fastq_reduce = search_file('fastq_reduce.pl', path)
if fastq_reduce and not os.path.exists("./fastq_reduce.pl"):
        log.info("fastq_reduce located: " + fastq_reduce)
        os.symlink(fastq_reduce, "fastq_reduce.pl")
elif not os.path.exists("./fastq_reduce.pl"):
        log.error("Unable to find fastq_reduce.pl script")
        sys.exit(3)


bwa = search_file("bwa", path)
if bwa and not os.path.exists("./bwa"):
        log.info("BWA located: " + bwa)
        os.symlink(bwa, "bwa")
elif not os.path.exists("./bwa"):
        log.error("Unable to find bwa")
        sys.exit(3)


cat_bwa = search_file("cat_bwa", path)
if cat_bwa and not os.path.exists("./cat_bwa"):
        log.info("Cat_bwa located: " + cat_bwa)
        os.symlink(cat_bwa, "cat_bwa")
elif not os.path.exists("./cat_bwa.pl"):
        log.error("Unable to find cat_bwa")
        sys.exit(3)

if options.makeflow is None:
	makeflow = sys.stdout
else:
	makeflow = open(options.makeflow, 'w')

try:
	if options.config:
		config = open(options.config, 'r')
		makeflow.write(config.read())

	splits = count_splits(options.fastq)
	rsplits = 0
	inputlist = ""
	for i in range(splits):
		inputlist = inputlist + options.fastq + "." + str(i) + " "

	makeflow.write("\n\n"+inputlist + "numsplits.txt : fastq_reduce.pl " + options.fastq);
	makeflow.write("\n\tperl fastq_reduce.pl "+options.fastq+" > numsplits.txt 2>&1")

	if options.rfastq:

		rsplits = count_splits(options.rfastq)
		rinputlist = ""
		for i in range(rsplits):
			rinputlist = rinputlist + options.rfastq + "." + str(i) + " "

		makeflow.write("\n\n"+rinputlist+"rnumsplits.txt : fastq_reduce.pl "+options.rfastq);
		makeflow.write("\n\tperl fastq_reduce.pl "+options.rfastq+" > rnumsplits.txt")

 # Rule and Command for Indexing FASTA File
	ref = options.ref

	if options.prefix:
		ref = options.prefix
		index_arg += "-p " + ref + " "

	index = ref+".bwt "+ref+".pac "+ref+".amb "+ref+".ann "+ref+".sa "

	makeflow.write("\n\n"+index+ ": bwa "+options.ref)
	makeflow.write("\n\t./bwa index " + index_arg + options.ref + " 2>&1")

	index = options.ref + " " + index
	results_to_cat = ""
    
	for c in range(splits):
		sc=str(c)
		query1=query2=sai1=sai2=output=""
		
		query1 = options.fastq + "." + sc + " " 
		sai1 = query1[:-1] + ".sai "
		if options.rfastq:
			query2 = options.rfastq + "." + sc + " " 
			sai2 = query2[:-1] + ".sai "
		
		output = "BWAMF.output." + sc + " "
		results_to_cat += output

		if options.algoalign=="bwa_backtrack":
			
			makeflow.write("\n\n"+sai1+" : bwa "+index+query1)
			makeflow.write("\n\t./bwa aln "+aln_arg+ref+" "+query1+"> "+sai1+" 2>&1")

			if options.rfastq:
				makeflow.write("\n\n"+sai2+" : bwa "+index+query2)
				makeflow.write("\n\t./bwa aln "+aln_arg+ref+" "+query2+"> "+sai2+" 2>&1")

				makeflow.write("\n\n"+output+": bwa "+index+query1+query2+sai1+sai2)
				makeflow.write("\n\t./bwa sampe "+sampe_arg+ref+" "+sai1+sai2+query1+query2+" > "+output+" 2>&1")
			else:
				makeflow.write("\n\n"+output+": bwa "+index+query1+sai1)
				makeflow.write("\n\t./bwa samse "+samse_arg+ ref+" "+sai1+guery1+" > "+output+" 2>&1")

		else:
			algo = "mem "
                        args = bwamem_arg + "-v 0 "
			if(options.algoalign=="bwa_sw"):
				algo = "bwasw "
				args = bwasw_arg
      
			makeflow.write("\n\n"+output+": bwa "+ index + query1 + query2)
			makeflow.write("\n\t./bwa "+algo+args+ref+" "+query1+query2+" > "+output+" 2>&1")

	output = "bwa_results.sam "
	if options.output_SAM:
		output = options.output_SAM + " "
	
	makeflow.write("\n\n"+output+": cat_bwa.pl "+results_to_cat)
	makeflow.write("\n\t./cat_bwa.pl "+output+results_to_cat)	

finally:
	if options.makeflow is not None:
		makeflow.close()
