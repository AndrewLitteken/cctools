# Copyright (c) 2010- The University of Notre Dame.
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.


PRUNE: A Preserving RUN Environment for scientific workflows

This program is designed to enable users to preserve large scale workflow executions and revisions. The user has complete control over the granularity at which each step of the workflow is defined.





The following basic commands are fundamental to PRUNE:

**PUT [local.txt] AS [prune_name]: Files to be used in the workflow can be added to the preserved namespace.
  Ex. PUT mylocalfilename.txt AS data_name_in_prune

**GET [prune_name] AS [local.txt]: Files generated by the workflow can be put into the user's namespace for use by some external program.
  Ex. GET data_name_in_prune AS mylocalfilename.txt

**WORK [FOR <timeout>]: Blocking function that instructs PRUNE to start executing the workflow with whatever resources are available.
  Ex. WORK FOR 60    #Block for 60 seconds so PRUNE can work

**USE <framework> [<arguments>]: Define how the execution should be performed
  Ex. USE wq prune      #Start and use a Work Queue master with the name 'prune'
  Ex. USE local 1      	#Use 1 local execution thread

**EVAL <name(s)> = <expression> (default): Evaluate an expression and assign the results to the specified name(s). Work defined in these statements will not be executed until control is passes to PRUNE such as with USE and WORK commands.
  Ex. sorted_data = sort(input_data)

Functions are currently defined within a script file (which is PUT in the system) to define the types of arguments the script expects and the output files that should be preserved.
  Ex.  #PRUNE_INPUTS File File Text
  Ex.  #PRUNE_OUTPUT outfile1.txt
  Ex.  #PRUNE_OUTPUT outfile2.txt




The following commands are also available for convenience:

*MF <name>: Covert the makeflow rules in the file into PRUNE function invocations.
*RUN <name>: Treat each line in a file as if it were typed into the PRUNE interface.
*RESET: Truncate the database and delete and data files and sandboxes.
*LOCATE <name>: Show where the file is cached in PRUNE (if available)
*ENV <prune_name>: Define the environment in which an execution should be performed
  Ex. PUT spec.json AS cms_env ENV umbrella     #Use the umbrella specification 
  Ex. PUT env.tar.gz AS py_libs ENV targz  		#Extract the file containing libraries
  Ex. ENV cms_env								#Switch back to the umbrella environment





When PRUNE is started using the "prune" executable, an interface becomes available for the user to type commands. Ctrl-C will terminate PRUNE and upon restarting any previously running tasks revert to the "Run" status.

The user will be initially prompted to specify locations for a database file, data folder, and sandbox folder. This meta-data will be stored in the working directory as a file named .prune.conf for PRUNE to use later.



Here is a full example of a merge sort in PRUNE:

$ prune
PRUNE$ PUT sort.sh AS sort
PRUNE$ PUT merge.sh AS merge
PRUNE$ PUT nouns.txt AS nouns
PRUNE$ PUT verbs.txt AS verbs
PRUNE$ n = sort(nouns)                  
PRUNE$ v = sort(verbs)                  
PRUNE$ merged_result = merge(n,v)
PRUNE$ USE wq prune
Work Queue master started on port 9001 with name 'prune'...
PRUNE$ WORK
...
PRUNE finished work in: 01m16s
PRUNE$ GET merged_result AS test.txt           
PRUNE$


File --- sort.sh ---
#!/bin/bash
#PRUNE_INPUTS File
#PRUNE_OUTPUT sorted_data.txt
sort $1 > sorted_data.txt

File --- merge.sh ---
#!/bin/bash
#PRUNE_INPUTS File*
#PRUNE_OUTPUT merged_output.txt
sort -m $@ > merged_output.txt 

